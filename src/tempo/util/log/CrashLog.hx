package tempo.util.log;

#if CRASH_HANDLER
import tempo.util.MemoryUtil;
import tempo.util.DateUtil;
import flixel.FlxG;
import flixel.util.FlxSignal.FlxTypedSignal;
import openfl.events.UncaughtErrorEvent;

@:nullSafety
class CrashLog
{
  public static function init()
  {
    Sys.println('Crash Log: Standard uncaught error handler enabling...');
    flixel.FlxG.game.loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, standardError);

    #if (cpp && !debug) // for debug build - idk where a error
    Sys.println('Crash Log: C++ critical error handler enabling...');
    untyped __global__.__hxcpp_set_critical_error_handler(criticalError);
    #end
  }

  public static var standardSignal(default, null):FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();

  static function standardError(e:UncaughtErrorEvent)
  {
    try
    {
      standardSignal.dispatch(CrashReference.generateMsg(e));
      CrashReference.displayError(e);

      #if sys
      CrashReference.logError(e);
      #end

      openfl.system.System.exit(1);
    }
    catch (e)
      Sys.println('Crash Log: Handling Error: $e');

    trace(e);

    openfl.system.System.exit(1);
  }

  #if (cpp && !debug)
  public static var criticalSignal(default, null):FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();

  static function criticalError(e:String)
  {
    try
    {
      criticalSignal.dispatch(e);
      CrashReference.displayErrorMsg(e);

      #if sys
      CrashReference.logErrorMsg(e, true);
      #end

      openfl.system.System.exit(1);
    }
    catch (e)
    {
      Sys.println('Crash Log: Critical Handling Error: $e');
      Sys.println('Message: $e');
    }

    trace(e);

    openfl.system.System.exit(1);
  }
  #end

  static final pr:String = "======================";

  public static function createContent(msg:String):String
  {
    final driverInfo:String = flixel.FlxG?.stage?.context3D?.driverInfo ?? 'N\\A';
    final curState:String = flixel.FlxG.state != null ? Type.getClassName(Type.getClass(flixel.FlxG.state)) : 'Unknown State';

    var fc:String = '$pr\n';
    fc += '| Tempo Crash Dialog |\n';
    fc += '$pr\n\n';
    fc += 'Generated BY: ${Constants.CRASH_GENERATED_BY}\n';
    fc += 'Crashed at: ${DateUtil.generateTimestamp()}\n';
    fc += 'Driver Info: ${driverInfo}\n';
    fc += 'Platform: ${Sys.systemName()}\n';
    fc += 'Render method: ${CrashReference.renderMethod()}\n\n';
    fc += MemoryUtil.buildGCInfo() + '\n\n';
    fc += '$pr\n\n';
    fc += 'Flixel Current State: ${curState}\n\n';
    fc += '$pr\n\n';
    fc += 'Haxelibs: \n';

    for (lib in Constants.LIBRARY_VERSIONS)
      fc += '- ${lib}\n';

    fc += '\n';
    fc += '$pr\n\n';
    fc += msg;
    fc += '\n';

    return fc;
  }
}

@:keep
@:nullSafety
@:access(tempo.util.log.CrashLog)
private class CrashReference
{
  public static function displayError(e:UncaughtErrorEvent):Void
    displayErrorMsg(generateMsg(e));

  public static function displayErrorMsg(e:String):Void
    openfl.Lib.application.window.alert('| TEMPO CRASH LOG |\n${CrashLog.pr}\n' + e + '\n${CrashLog.pr}\n\nReporting here: ${Constants.GITHUB_URL}/issues',
      "Fatal Uncaught Error!");

  #if sys
  public static function logError(e:UncaughtErrorEvent)
    logErrorMsg(generateMsg(e));

  public static function logErrorMsg(e:String, c:Bool = false)
  {
    if (!sys.FileSystem.exists('./logs/')) sys.FileSystem.createDirectory('./logs');

    Sys.println("\nGame crash dump in: " + haxe.io.Path.normalize('./logs/tempo-crash${c ? '-critical' : ''}-${DateUtil.generateTimestamp()}.log'));

    sys.io.File.saveContent('./logs/tempo-crash${c ? '-critical' : ''}-${DateUtil.generateTimestamp()}.log', CrashLog.createContent(e));
  }
  #end

  public static function renderMethod():String
  {
    var output:String = 'UNKNOWN';
    output = try
    {
      switch (FlxG.renderMethod)
      {
        case FlxRenderMethod.DRAW_TILES: 'DRAW_TILES';
        case FlxRenderMethod.BLITTING: "BLITTING";
        default: 'UNKNOWN';
      }
    }
    catch (e)
      'ERROR ON QUERY RENDER METHOD: $e';

    return output;
  }

  public static function generateMsg(e:UncaughtErrorEvent):String
  {
    var msg:String = "";
    var callStack:Array<haxe.CallStack.StackItem> = haxe.CallStack.exceptionStack(true);

    msg += '${e.error}\n';

    for (stackItem in callStack)
    {
      switch (stackItem)
      {
        case FilePos(innerStackItem, file, line, column):
          msg += ' ${file}#${line}' + (innerStackItem != null ? ' [StackItem(${innerStackItem})]' : '');
          if (column != null) msg += ':${column}';
        case CFunction:
          msg += '[Function] ';
        case Module(m):
          msg += '[Module(${m})] ';
        case Method(classname, method):
          msg += '[Function(${classname}.${method})] ';
        case LocalFunction(v):
          msg += '[LocalFunction(${v})] ';
        default:
          Sys.println(stackItem);
      }
      msg += '\n';
    }

    return msg;
  }
}
#end
